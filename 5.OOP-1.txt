● 객체 지향 프로그래밍(OOP - Object Oriented Programming)
   
  - 현실세계에 존재하는 사물을 모델링하여 클래스 자료형 작성 후 객체
    (Object)를 생성하여 객체 요소를 사용하여 프로그램을 작성하는 방법
     

   객체를 이용하여 프로그램을 만듬

  - 클래스 배포 가능 >> 프로그램 생산성 증가와 유지보수의 용이성 제공

  - 객체지향 프로그래밍 : 추상화, 캡슐화, 다형성, 상속성
   
  - 추상화(Abstraction) : 현실세계에 존재하는 사물을 속성(Field)과
    기능(Method)으로 구분하여 클래스로 만들어 주는 방법 
  
  
● 클래스(Class) - 참조형(Reference Type)

  - 인스턴스를 만들기 위한 자료형 >> 인스턴스(Instance) = 객체(Object)
  
  - 필드(Field)와 메소드(Method)의 모임
    
  - 클래스 선언 방법
  
    public class 클래스명 {
        필드(Field);//메소드에서 필요로 하는 정보를 제공할 목적의 변수
        ...

        생성자(Constructor);//인스턴스 생성을 목적으로 하는 메소드
        ...

        메소드(Method);//기능을 제공할 목적의 명령들의 모임
        ...
    }   

  - 인스턴스 생성 방법
  
    클래스명 참조변수=new 클래스명();
    
  - 인스턴스 사용 방법 

    >> 참조변수에 저장된 인스턴스 정보로 필드 또는 메소드 접근 - . 연산자 이용
  
   형식) 인스턴스정보.필드 or 인스턴스정보.메소드   
    

● 메소드(Method)

  - 필드에 저장된 정보를 제어하기 위한 명령들의 모임 >> 기능
  
  - 메소드 선언 방법
  
    자료형 메소드명(자료형 변수명, 자료형 변수명,...) {
         명령;
         ... 
    }
  
    >> 메소드 반환형(ReturnType - 결과형:ResultType) : 메소드를 호출하여 얻을 수 있는 결과의 자료형          
    
     ※ void : 무반환형 - 메소드를 호출하여 얻을 수 있는 결과가 없을 경우 사용하는 자료형 
  
    >> 메소드 매개변수(Parameter - 인자:Argument) : 메소드의 명령을 실행하기 위해 필요한 정보를 전달받아 저장하기 위한 변수
        
  - 메소드 호출(Method Invoke) 방법

    >> 메소드를 호출해야 메소드에 작성된 명령들이 실행되어 기능 제공
  
    형식) 인스턴스.메소드명(필요정보, 필요정보,...);  

     ※ 매개변수에 정보를 제대로 전달하지 않으면 메소드 호출 불가
     
  - return : 메소드를 종료하는 명령 - 제어문
  
    형식1) if(조건식) return;  >> 조건식의 결과가 참인 경우 메소드 종료 

    형식2) return 대상; >> 대상정보를 메소드 호출 명령으로 반환 

     ※ 대상의 자료형과 메소드 반환형의 자료형은 반드시 동일


● 캡슐화(Encapsulation) : 추상화 작업을 통해 작성된 클래스를 보다 견고하게 작성

  - 필드의 직접적인 접근을 제한하고 메소드를 이용하여 접근하도록 클래스를 작성 방법

  - 인스턴스가 필드에 직접 접근하여 사용될 경우 잘못된 정보 저장 가능
  
    >> 인스턴스가 필드에 직접 접근하는 것을 제한 - 정보 은닉화(Information Hiding)
      
  - 인스턴스가 필드에 접근할 수 없도록 private이라는 접근지정자(Access Modifier)를 이용하여 선언
  
    형식) private 자료형 변수명;
    
    >> 클래스 내부의 메소드에서만 접근 가능하며 클래스 외부에서 접근할 경우 에러 발생
    
  - 은닉화 선언된 필드에는 필드값 반환 또는 필드값 변경 목적의 메소드 선언

    >> Getter(is) 메소드(필드값 반환)와 Setter 메소드(필드값 변경) 선언 - 캡슐화
    
    >> 메소드는 모든 클래스에서 접근 가능하도록 public 접근지정자를 이용하여 선언
    
    형식) public 반환형 메소드명(파라메터,...) {
             명령;
             ...
          }

  - Getter 메소드 : 필드값 반환 목적의 메소드
  
    형식) public 자료형 get필드명() {
              return 필드명;//필드값 반환
          }
  
    ※ 필드 자료형이 boolean인 경우 메소드명은 "is필드명"으로 선언
    
  - Setter 메소드 : 필드값 변경 목적의 메소드
  
    형식) public void set필드명(자료형 파라메터명) {
              //파라메터값에 대한 유효성 검사
              필드명=파라메터명;//파라메터값으로 필드값을 변경
          }

    ※ 식별자 변경 : Refactor >> Rename (Alt+Shift+R)

       >> 빌드된 클래스의 모든 식별자가 동시에 변경
  
    ※ 이클립스에서는 Getter와 Setter 메소드를 자동으로 생성하는 기능 제공

       >> Alt+Shift+S >> R >> 필드 선택 >> Generate(OK)


● 메소드 오버로드(Method Overload)

  - 클래스에 동일한 이름의 메소드를 선언할 수 있는 방법
  
    >> 동일한 기능을 제공하는 메소드는 같은 이름의 메소드명으로 선언하는 것을 권장
  
  - 오버로드 작성 규칙
  
    >> 클래스에서 동일한 메소드명으로 선언하며 메소드 파라메터의 갯수,자료형등을 다르게 선언
    
    >> 메소드의 접근지정자, 반환형은 오버로드와 무관
    
  - 파라메터에 전달되는 값에 따라 다른 메소드 호출 : 다형성 
  
  - 다형성(Polymorphism)  : 동일한 이름의 메소드를 호출해도 때에 따라 다른 메소드가 호출되어 기능 제공
  
    >> 메소드 오버로드, 메소드 오버라이드   

  
● 생성자(Constructor)
  
  - 인스턴스를 생성을 목적으로 선언하는 특별한 메소드
`
    >> 기능 제공이 목적으로 하지 않는 메소드 - 인스턴스로 호출 불가능  
  
  - 생성자를 선언하지 않아도 내부적으로 기본 생성자가 있는 것으로 처리
  
    >> 생성자를 선언하지 않아도 기본 생성자로 인스턴스 생성 가능

   ※ 기본 생성자(Default Constructor) : 파라메터와 명령이 없는 생성자

  - 생성자를 선언하는 이유 : 초기화 작업
  
    >> 인스턴스 생성시 초기값을 전달하여 필드에 저장하기 위해 선언
    
    >> 인스턴스 생성 후 필요한 초기화 작업을 위해 선언 - GUI 프로그램의 디자인 작업 

  - 생성자 인스턴스를 만들때 자동 호출 => 인위적 호출 불가능

  - 생성자 작성 방법
  
    >> 반환형 미선언 - 값 반환 불가능
    
    >> 생성자명은 반드시 클래스명과 동일하게 작성
    
    >> 오버로딩 작성 가능 - 파라메터에 따라 여러개의 생성자 선언 가능

    형식) public 클래스명() { //Ctrl+Space >> Constructor 선택 >> Enter
  	      //기본 생성자는 명령 미작성
          }
          
          public 클래스명(파라메터,...) { //Alt+Shift+S >> O >> 필드 선택 >> Generate
              //인스턴스가 생성될때 실행될 명령 작성 - 필드 초기화
          } 

    >> 생성자를 하나라도 선언하면 기본적으로 제공하는 기본 생성자는 소멸
       되므로 기본 생성자를 반드시 선언하는 것을 권장 - 상속 문제 때문


● this : 메소드에서 클래스 자신의 인스턴스 정보를 저장하여 사용하기 위한 키워드

  - 메소드의 파라메터에 숨겨져 클래스의 인스턴스를 저장하는 참조변수
  
    >> 메소드를 호출한 인스턴스 정보를 자동으로 전달되어 저장
  
  - this 참조변수가 존재해야 되는 이유
  
    >> 클래스를 이용하여 인스턴스를 생성할 경우 필드는 인스턴스 
       마다 메모리에 따로 생성되지만 메소드는 클래스에 하나만 존재 => 메모리 절약
  
    >> 메소드에서 인스턴스 필드를 구분하기 위해 this 사용

  - this 키워드를 생략하여 표현하지 않아도 자동으로 인식

  - this 키워드를 이용해야 되는 경우
  
    1) 필드(this 사용)와 파라메터를 구분하기 위해 사용
    
      ex) public class Test {
               private int su;
               public void setSu(int su) {
                   this.su=su;
               }
          }
  
    2) 클래스의 생성자에서 다른 생성자를 호출하기 위해 사용
    
      >> 생성자의 초기화 코드가 중복될 경우 코드 중복 최소화를 위해 사용

      형식) this(값,...);//생성자 호출 - 생성자에서만 작성 가능한 코드 
  
      >> this 키워드로 생성자 호출하는 명령은 최초 명령으로만 작성 가능
  

● static : 인스턴스에 독립적인 필드 또는 메소드를 선언하기 위한 키워드
  
 1. static 필드 : 정적 필드
 
   - 모든 인스턴스가 공유하여 사용하는 필드 
   
   - 클래스가 메모리에 저장되면 하나만 생성되는 필드
    
     >> 인스턴스 생성과 무관 - 생성자 초기화 작업 불필요
      
   - static 필드 선언 방법
   
     접근지정자 static 자료형 필드명=초기값;

     >> 초기값이 생략될 경우 필드 기본값 저장
   
   - static 필드 접근 방법 : 클래스를 이용하여 필드 접근
   
     형식) 클래스명.필드 >> 필드가 private 접근지정자로 선언된 경우 접근 불가능
     
   - static 필드 사용 이유
   
     >> 메모리 절약과 데이타 변경 및 사용의 용이성  
      
 2. static 메소드 : 정적 메소드
   
   - this 참조변수가 존재하지 않는 메소드 
   
     >> 인스턴스 필드 또는 인스턴스 메소드 접근 불가능
     
     >> static 필드 또는 static 메소드 접근 가능

   - static 메소드 선언 방법
   
    형식) 접근지정자 static 반환형 메소드명(매개변수,... ) {
   	       static 필드값 제어 명령;
          }

   - static 메소드 호출 방법 : 클래스를 이용하여 메소드 호출 
   
    형식) 클래스명.메소드명(값,...);
    
   - static 메소드 사용 이유 : 메소드 간편 호출 
      
